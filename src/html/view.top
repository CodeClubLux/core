/** # Html
This package is used to render html to the browser.

Hello World

```
import "html"

html.render html.h1 \[], "Hello World!"

```
A Virtual Dom Node
@VNode

Native html elements.
@HtmlElem

Atom that updates the part of global state atom, using lenses
@PosAtom

Type of Events
@Event

@Attribute

@mapWithId

Initialize and render the application
@startApp

Render a single frame
@render

*/

type VNode with
    toString: || -> string

type Nothing with

type Patches with

type HtmlElem with
    innerHtml: string
    value: string

type PosAtom[X, T] =
    a: Atom[X]
    pos: Lens[X, T]

def PosAtom[X, T].unary_read(self) T do
    self.pos.query \<-self.a

def PosAtom[X, T].toString(self) string =
    let a = toString self.a
    let pos = toString self.pos

    a + pos


ext full cmpAtom: [T]|Atom[T], Atom[T]| -> bool = 'function(a,b) { return getPrototype(a) == getPrototype(b) && a.op_eq(b); }'
ext full cmpLens: [X,T]|Lens[X,T], Lens[X,T]| -> bool = 'function(a,b) { return getPrototype(a) == getPrototype(b) && a.op_eq(b); }'

def PosAtom[X, T].op_eq(self, other: PosAtom[X,T]) bool =
    (cmpAtom self.a, other.a) and (cmpLens self.pos, other.pos)

def PosAtom[X, T].update(self, func: |T| -> T) do
    let current = <-self.a
    self.a.op_set self.pos.set current, func self.pos.query current

def PosAtom[X, T].op_set(self, new: T) do
    self.a.op_set self.pos.set \<-self.a, new

def PosAtom[X, T].watch(self, f: |T| do none) do
    def func(x: X) do
        f self.pos.query \<-self.a

    self.a.watch func

def pipeAtom[T](funcs: []|Atom[T]| do none, a: Atom[T]) Atom[T] do
    funcs.serial |i: |Atom[T]| do none| do i(a)
    a

type Event =
    target: HtmlElem

type Attribute =
    name: string
    value: Nothing

def newAttrib[T](name: string, value: T) Attribute =
    Attribute{name, value}

ext client registerEvent: [A,B]||A,B| do A, Atom[A]| do none = "_html_register"
ext full log-any: |Any| -> none = "console.log"

def onEvent[T](name: string, x: |T, Event| do T, a: Atom[T]) Attribute =
    Attribute{name, {a = a, x = x}}


/*
ext client setUrl: |string| do none = "_html_setUrl"
ext client setLocalStorage: |Any| do none = "_html_setLocalStorage"
ext client readLocalStorage: [T]||Any| -> T| do Maybe[T] = "_html_readLocalStorage"

ext client page-load-url: string = "window.location.hash.slice(1)"
*/

def ignoreAct[T](f: |T| do T) |T, Event| do T =
    def func(x: T, y: Event) T do
        f x

    func

ext client nextTick: ||| do none| do none = "_nextTick"

def withId[T](f: |T, Event| do T) |int, []T, Event| do []T =
    def func(id: int, m: []T, e: Event) []T do
        let res = (f m[id], e)
        m.set id, res

    func

def mapWithId[T, X](v: |T, int, Atom[X]| -> VNode, arr: []T, a: Atom[X]) VNode =
    def func(id: int) VNode =
        v arr[id], id, a

    [0..arr.length].map func

def toEffect[T](f: |T, Event| -> T) |T,Event| do T =
    def func(x: T, ev: Event) T do
        f x, ev

    func

def pure[T](f: |T| -> T) |T, Event| do T =
    def func(x: T, ev: Event) T do
        f x

    func

def mapView[T](v: |T, Atom[T]| -> VNode, model: []T, a: Atom[[]T]) VNode =
    def mapper(idx: int) VNode =
        let result = model[idx]

        let pos = (lens[idx])
        let newA = PosAtom{a, pos}

        v result, newA

    [0..model.length].map mapper

def fromLens[T, X, R](v: |X, Atom[X]| -> R, model: T, a: Atom[T], pos: Lens[T, X]) R =
    v (pos.query model), PosAtom{a, pos}


def new-embed[T,X,R](model: T, a: Atom[T]) ||X,Atom[X]| -> R, Lens[T,X]| -> R =
    fromLens _, model, a, _

let style: |string| -> Attribute = newAttrib::[string] "style"
let placeHolder: |string| -> Attribute = newAttrib::[string] "placeholder"
let position = newAttrib::[string] "position"
let _type = newAttrib::[string] "type"
let height = newAttrib::[string] "height"
let width = newAttrib::[string] "width"
let key = newAttrib::[int] "key"

ext client addClassOnVisible: |string| -> Attribute = "html_addClassOnVisible"

let innerHtml = newAttrib::[string] "innerHTML"

let id = newAttrib::[string] "id"

let min = newAttrib::[int] "min"
let max = newAttrib::[int] "max"
let step = newAttrib::[int] "step"
let value = newAttrib::[string] "value"
let href = newAttrib::[string] "href"
let src = newAttrib::[string] "src"
let disabled = newAttrib::[bool] "disabled"
let multiple = newAttrib::[[]Attribute] "multiple"

type Transition =
    duration: int
    enterClass: string
    leaveClass: string

let transition = newAttrib::[Transition{}] "transition"

let _kind = newAttrib::[string] "type"

let _float = newAttrib::[string] "float"

let class = newAttrib::[string] "className"
let frameborder = newAttrib::[string] "frameborder"
let scrolling = newAttrib::[string] "scrolling"

let _async = newAttrib::[bool] "async"
let charset = newAttrib::[string] "charset"

let onClick = onEvent "onclick"
let onInput = onEvent "oninput"
let onChange = onEvent "onchange"


def attribute(name: string, v: Any) Attribute =
    Attribute{name, v}

let _defer = newAttrib::[bool] "_defer"

ext client h: |string, []Attribute, VNode| -> VNode = "html_hyper"
ext client createElement: |VNode| -> HtmlElem = "virtualDom.create"
ext client diff: |VNode, VNode| -> Patches = "virtualDom.diff"
ext client patch: |HtmlElem, Patches| do HtmlElem = "toAsync(virtualDom.patch)"

ext client clear: |HtmlElem| do none = "toAsync(clearElement)"

//ext diff: |VNode, VNode| do Patches = "require('virtual-dom/diff');"
//ext patch: |VNode, Patches| do none = "require('virtual-dom/patch');"

ext client cssSelector: |string| -> HtmlElem = "document.querySelector.bind(document)"

let h1 = h "h1"
let h2 = h "h2"
let h3 = h "h3"
let h4 = h "h4"
let h5 = h "h5"
let h6 = h "h6"
let br = h "br"

let blockquote = h "blockquote"
let script = h "script"

let iframe = h "iframe"


let hr = h "hr"

let button = h "button"
let input = h "input"

let noAttrib: []Attribute = []

let div = h "div"

let p = h "p"
let ul = h "ul"
let li = h "li"
let link = h "a"

let image = h "img"
let span = h "span"

let text-area = h "textarea"

ext client _appendChild: |HtmlElem, HtmlElem| do none = "toAsync(html_appendChild)"
ext client stringToH: |Stringable| -> Stringable = "_html_stringToH"

def render(newTree: VNode) HtmlElem do
    let rootNode= createElement stringToH newTree
    let root = cssSelector "#code"

    _appendChild root, rootNode

    rootNode

def startApp[T](r: |T, Atom[T]| -> VNode, appstate: Atom[T]) do
    var oldV = stringToH r (<-appstate), appstate

    var root = render oldV

    def rerender(i: T) do
        let newV = stringToH r i, appstate

        let patches = diff oldV, newV

        root = patch root, patches

        oldV = newV

    appstate.watch rerender